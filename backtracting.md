# 回溯算法！！！
## 1. 组合问题（Combinations）

组合问题是回溯算法中最典型、最基础的题型之一。  
目标是在给定范围内，按要求选出若干元素，**强调“元素无序（顺序不重要）且不能重复选”**。

典型题目：  
- [LeetCode 77. Combinations](https://leetcode.cn/problems/combinations/description/)  
- 从 1~n 中选 k 个数，返回所有组合。

组合问题的标准特征：
- 选与不选  
- 顺序不敏感（[1,2] 与 [2,1] 视为同一组合）  
- 往往需要“从 i 开始选，下一层从 i+1 开始”来避免重复  
- 可以通过剪枝进行性能优化  

接下来进入详细的回溯分析与代码实现。

---

### 1.1 回溯算法思想概述

回溯（Backtracking）是一种“构建解 → 判断 → 撤销 → 换一种选法”的深度优先探索。

解决组合问题的核心思想：

1. **路径（path）**：当前已经选择的数字  
2. **选择列表（choices）**：还能选择哪些数字  
3. **结束条件**：当 path 的长度达到 k 时，得到一个组合

回溯本质 = 构建一条搜索路径，再在返回时撤回选择，继续探索其它路径。

---

### 1.2 回溯树结构（理解组合问题的关键）

以 n = 4, k = 2 为例，组合的选择过程是一棵树：
```

             []

      /       |       \
    [1]      [2]      [3]
   /   \     / \        \

[1,2] [1,3] [2,3] [2,4]   [3,4]
```
每条从根到叶子的路径（长度 = k）就是一个合法组合。

回溯算法就是按照这棵隐含搜索树进行 DFS。

---

### 1.3 剪枝思想（Pruning）

如果还需要选 `k - path.size()` 个数字，但剩余数字不够，则无法构成组合，可以提前停止。

例如在 n=4, k=3 时：

当 path=[3] → 剩余数字只有 {4} 1 个，但需要选 2 个 → 必然失败 → 直接剪枝

剪枝判断公式：

> i <= n - (k - path.size()) + 1

这个条件显著减少递归深度，加速回溯。

---

### 1.4 代码模板（最优写法）

下面给出 C++ 的组合问题标准模板，可直接用于所有“选 k 个”的组合题。

```cpp
class Solution {
private:
    vector<vector<int>> result;  // 存放最终结果
    vector<int> path;            // 当前路径（组合）
    
    void backtracking(int n, int k, int startIndex) {
        // 终止条件：选满 k 个
        if (path.size() == k) {
            result.push_back(path);
            return;
        }

        // 剪枝：i 的上界保证剩余数字足够
        for (int i = startIndex; i <= n - (k - path.size()) + 1; i++) {
            path.push_back(i);                  // 做选择
            backtracking(n, k, i + 1);         // 下一层选择从 i+1 开始
            path.pop_back();                   // 回溯（撤销选择）
        }
    }

public:
    vector<vector<int>> combine(int n, int k) {
        backtracking(n, k, 1);
        return result;
    }
};
```

⸻

### 1.5 代码逐行解释
	•	result：保存所有组合
	•	path：保存当前正在构造的组合
	•	startIndex：控制下一轮从哪里开始选择，避免重复

核心逻辑：
	1.	选择数字 i
path.push_back(i)
	2.	递归进入下一层，从 i+1 开始选
保证组合是递增的、无重复
	3.	回到上一层 → 撤销选择
path.pop_back()

剪枝部分：

i <= n - (k - path.size()) + 1

意思是：剩余可选数字必须够用，否则不进入分支。

⸻

### 1.6 示例 walkthrough（n=4, k=2）

回溯过程：

path=[]
i=1 → path=[1]
    i=2 → [1,2] ✔
    i=3 → [1,3] ✔
    i=4 → [1,4] ✔
回溯到 []
i=2 → path=[2]
    i=3 → [2,3] ✔
    i=4 → [2,4] ✔
回溯到 []
i=3 → path=[3]
    i=4 → [3,4] ✔
回溯到 []

结束。

最终输出：

[1,2]
[1,3]
[1,4]
[2,3]
[2,4]
[3,4]


⸻

### 1.7 组合问题的通用回溯模板（可复用）

如果你遇到更多类似的“从 N 个数字里选 K 个”，可以直接套下面这个模板：

def backtracking(start):
    if 选够了K个:
        收集结果
        return

    for i from start to n:
        做选择 i
        backtracking(i+1)
        撤销选择 i

剪枝版本：

> for i from start to n - (k - path.size()) + 1:

这是组合类问题的 万能模板。

⸻

### 1.8 小结

组合问题的本质：
	1.	树形结构的 DFS 搜索
	2.	每次选 or 不选当前数字
	3.	保证选出的数字递增（从 i → i+1）
	4.	剪枝保证剩余数字够用
	5.	路径达到 k 就是合法组合

下面给你写一份**从 2 开始的 Combination Sum II（LeetCode 40）专题笔记**，风格与之前的回溯专题保持一致，标题清晰、结构规整、带树形图讲解“为什么不去重会生成重复答案”。

---

## 2. 组合问题：Combination Sum II（去重版）

[Combination Sum II](https://leetcode.cn/problems/combination-sum-ii/) 是组合类回溯题中非常典型也非常“精细”的一个分支：
**数组中有重复元素，但结果中不能出现重复组合。**

这就与上一题纯“组合问题”相比，多了一个关键任务：
**控制同一层的重复选择。**

整理得更完整一点，这道题有三个要点：

1. 每个数只能选一次（典型组合问题特征；回溯下一层传 `i+1`）
2. 数组可能含重复元素
3. 最终输出的组合不能重复

---

### 2.1 题目示例（核心示例）

输入：

```
candidates = [10,1,2,7,6,1,5]
target = 8
```

输出：

```
[
  [1,1,6],
  [1,2,5],
  [1,7],
  [2,6]
]
```

第一眼容易忽视的重点：

* 输入数组里 **两个 1 不挨着**
* 输出中允许出现两个 1，但每个组合只能出现一次（结果不能重复）

所以如何避免重复，是我们接下来要分析的重点。

---

### 2.2 回溯模型

这个题仍然是标准回溯框架：

```
for 从 start 到 末尾:
    做选择
    递归（i+1）
    撤销选择
```

关键差异：
**需要去重 → 必须排序 → 然后跳过同层重复值。**

---

### 2.3 为什么会产生重复？（非常关键）

排序后的数组是：

```
[1,1,2,5,6,7,10]
 index: 0 1 2 3 4 5  6
```

其中 index 0 和 1 都是 **1**。

---

### 2.4 ● 不加去重时，会产生两个 `[1,7]`

看搜索路径（这是理解本题的核心）：

### 路径一：从 index 0 的 1 出发

```
选择 1(a, index 0)
  → 继续搜索到 7
    → 得到 [1,7]
```

### 路径二：从 index 1 的 1 出发

```
选择 1(b, index 1)
  → 继续搜索到 7
    → 又得到 [1,7]
```

两条路径走出来的组合内容一样，但来自不同的数组位置。
如果不做去重，这两个路径都会被记录下去。

也就是说：

```
ans = [
  [1,7],   // 来自 1(a)
  [1,7],   // 来自 1(b)
]
```

组合重复一模一样。

---

### 2.5 ● 不加去重时，也会产生两个 `[1,2,5]`

结构完全相同：

```
1(a) → 2 → 5   => [1,2,5]
1(b) → 2 → 5   => [1,2,5]
```

只要 value 一样，路径的值序列就一样，但你却 push 两次 —— 重复不可避免。

---

### 2.6 ● 本质原因

**同一层的“重复数字”生成了“重复的递归起点”。**

路径不同，但组合相同，这是“同层重复”的经典特征。

关键词：**同层（重要！）**

如果概念还没完全稳固，可以看下面的图。

---

### 2.7 搜索树图示：展示重复是如何出现的

画顶层搜索树（未去重）：

```
                           []
            ------------------------------------------
            1(a)         1(b)        2        5 ...
```

注意：

* 1(a) 和 1(b) 在同一层（都在根节点下面）
* 每个都会继续往下扩展
* 后续看到的 2、5、6、7 都一样

于是就出现了：

```
1(a) → 7  -- produces --> [1,7]
1(b) → 7  -- produces --> [1,7]  (duplicate)
```

或者：

```
1(a) → 2 → 5 --> [1,2,5]
1(b) → 2 → 5 --> [1,2,5] (duplicate)
```

这就是不去重的搜索树。

重复完全不是 BUG，而是树本身带来的。

---

### 2.8 如何去重？（同层去重核心语句）

为了避免“同层重复展开”，我们使用：

```cpp
if (i > start && candidates[i] == candidates[i - 1]) 
    continue;
```

含义：

* `i > start`：说明这是**同一层**的后续节点
* `candidates[i] == candidates[i-1]`：说明值重复
* → 快速跳过该节点，不允许它作为新的起点产生另一棵子树

效果：

* 只允许同层重复数字中的 **第一个** 作为起点
* 对于组合问题，这恰好能去掉所有重复路径

搜索树变成：

```
                        []
       ------------------------------------------
       1(a)           2        5        6 ...
   （1(b) 被剪掉）
```

于是：

* `[1,7]` 只会出现一次
* `[1,2,5]` 只会出现一次
* `[1,1,6]` 仍然会出现一次（因为这个不是同层重复）

---

### 2.9 完整代码模板

这是最终可用、逻辑最清晰的写法：

```cpp
class Solution {
public:
    vector<vector<int>> ans;
    vector<int> path;

    void dfs(vector<int>& candidates, int target, int start) {
        if (target == 0) {
            ans.push_back(path);
            return;
        }

        for (int i = start; i < candidates.size(); ++i) {
            // ——【同层去重】：跳过同一层重复的数字
            if (i > start && candidates[i] == candidates[i - 1]) 
                continue;

            if (candidates[i] > target) 
                break;

            path.push_back(candidates[i]);
            dfs(candidates, target - candidates[i], i + 1);  // i+1 保证每个元素最多用一次
            path.pop_back();
        }
    }

    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end());
        dfs(candidates, target, 0);
        return ans;
    }
};
```

---

### 2.10 本节总结（你可以直接放进笔记里）

1. 本题的核心是 **同层去重**。
2. 不去重时，相同的数字会在同一层生成多个递归起点，导致重复组合。
3. 排序 + `(i > start && candidates[i] == candidates[i-1]) continue;`
   可以有效避免重复。
4. 组合问题用 `i+1` 控制每个数只能使用一次。
5. 通过画搜索树，可以清楚看到为什么重复会出现、为什么去重能消灭重复。
