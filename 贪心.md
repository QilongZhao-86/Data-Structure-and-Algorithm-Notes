# 贪心
## 1. 根据身高重建队列（Queue Reconstruction by Height）
题目链接：[根据身高重建队列（Queue Reconstruction by Height）](https://leetcode.cn/problems/queue-reconstruction-by-height/)

### 1.1 题目抽象

每个人用一个二元组表示：

[h, k]

其中：
- h 表示身高
- k 表示在他前面 **身高 ≥ h 的人数**

目标是重建一个队列，使得队列中每个人都满足自己的 (h, k) 条件。

---

### 1.2 为什么这不是一道普通排序题

直觉上可能会尝试：
- 按身高排序
- 按 k 排序
- 或同时排序

但这些方法都会失败，因为每个人的位置不仅取决于自己，
还取决于其他人站在哪里，这是一个 **相互约束问题**。

这类问题的关键不是“排好序”，而是：
先固定 **不会被影响的约束**，再处理 **会被影响的变量**。

---

### 1.3 核心观察：高个子看不到矮个子

这是整道题最关键的一点。

题目只关心：
在一个人前面，身高 ≥ 他的人数。

因此：
- 矮个子站在高个子前面，不会被计数
- 矮个子的位置变化，不影响高个子的条件

结论是：
**高个子的位置只受高个子影响，与矮个子无关。**

这使得我们可以放心地先处理高个子。

---

### 1.4 贪心策略的因果反转

基于上面的观察，可以采用如下贪心策略：

1. 先安排所有高个子的位置
2. 在高个子位置固定后，再插入矮个子

这是一个“因果反转”的过程：
不是从前往后排队，
而是从 **约束最强、最不容易被破坏的人开始处理**。

---

### 1.5 排序规则的设计

为了先处理高个子，需要对数组进行排序：

1. 按身高 h **降序排序**
2. 身高相同的情况下，按 k **升序排序**

排序的意义：
- 身高高的人优先确定位置
- 同身高时，k 小的人必须站得更靠前

对应的 C++ 排序代码为：

```cpp
sort(people.begin(), people.end(),
     [](const vector<int>& a, const vector<int>& b) {
         if (a[0] != b[0]) return a[0] > b[0];
         return a[1] < b[1];
     });
````

---

### 1.6 插入过程与不变量

维护一个结果队列 `res`，初始为空。

依次遍历排序后的 `people`，对每一个人 `p = [h, k]`：

```cpp
res.insert(res.begin() + k, p);
```
```
插入时始终保持如下不变量：

* `res` 中的所有人身高都 ≥ 当前插入的人
* 插入到下标 k 位置后，当前人前面恰好有 k 个身高 ≥ 他的人

该不变量在后续插入中不会被破坏。

---

### 1.7 为什么后插入的人不会影响已满足条件的人

后插入的人只可能是：

* 身高更矮的人
* 或身高相同但 k 更大的人

他们即使插入到队列前部：

* 对更高的人来说不会被计数
* 对同高且 k 较小的人，其相对顺序已被排序保证

因此，一旦一个人的条件被满足，就永远不会再被破坏。

---

### 1.8 完整 C++ 实现

```cpp
class Solution {
public:
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort(people.begin(), people.end(),
             [](const vector<int>& a, const vector<int>& b) {
                 if (a[0] != b[0]) return a[0] > b[0];
                 return a[1] < b[1];
             });

        vector<vector<int>> res;
        for (auto& p : people) {
            res.insert(res.begin() + p[1], p);
        }
        return res;
    }
};
```

---

### 1.9 小结

这道题的关键不在于“如何插入”，
而在于 **为什么可以先忽略矮个子**。

通过识别“不被影响的对象”，
将一个相互依赖的问题转化为单向构造问题，
这正是贪心算法成立的根本原因。

一句话总结：

高个子定义秩序，矮个子服从秩序。


